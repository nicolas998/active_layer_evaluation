# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['get_intersec', 'percentiles']

# Cell
import numpy as np
import pandas as pd
import plotly as pl

def get_intersec(metric, prod1, prod2, Me ,y1 = '2002', y2 = '2018'):
    '''Get the intersection for a given metric between two products of the event metrics data
    Inputs:
        -metric: the nme of the metric to analize.
        -prod1 and prod2: the products from to get the interserctio.
        -Me: MEtrica table with the products and the metrics.
        -y1 and y2: initial and end years to analize.'''
    Mec = Me.loc[y1:y2]
    a = Mec[[metric,'link']][Mec['product'] == prod1]
    a.set_index([a.index, a.link], inplace=True)
    #a.drop_duplicates(inplace = True)
    b = Mec[[metric,'link']][Mec['product'] == prod2]
    b.set_index([b.index, b.link], inplace=True)
    #b.drop_duplicates(inplace = True)
    idx = a.index.intersection(b.index)
    return a,b,idx

def percentiles(obs, sim, steps = 10, bins = None, perc = 50, percMax = 99.5):
    '''Obtains the percentile for the sim value that corresponds to
    an oberved value.
    Parameters:
        -obs: observed peaks or time serie.
        -sim: simulated peaks or time serie.
        -steps: number of splits to estimate the percentile.
        -perc: percentile to estimate
        -percMax: Max value to divide the observations.
    Returns:
        -A vector (2,N) where the first row corresponds to the percentiles
        at the observation and the second to the percentiles at the simulation'''
    if bins is None:
        bins = np.linspace(obs.min(), np.percentile(obs, percMax), steps)
    X = []; Y = []
    for i,j in zip(bins[:-1], bins[1:]):
        Y.append(np.percentile(sim[(obs>i) & (obs<=j)], perc))
        X.append((i+j)/2.)
        #Y.append(np.percentile(sim[(obs>i) & (obs<=j)], perc))
    return np.vstack([X,Y])